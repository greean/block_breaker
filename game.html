<!DOCTYPE html>
<html lang="en">
<head>
  <meta content="text.html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8" http-equiv="encoding">
  <title>Block Breaker</title>
</head>
<body> 
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <script>
    let ballX = 75;
    let ballY = 75;
    let ballSpeedX = 5;
    let ballSpeedY = 7;

    const BRICK_W = 80;
    const BRICK_H = 20;
    const BRICK_GAP = 2;
    const BRICK_COLS = 10;
    const BRICK_ROWS = 14;
    let brickGrid = new Array(BRICK_COLS * BRICK_ROWS);  // array identifier for each brick


    const PADDLE_WIDTH = 100;
    const PADDLE_THICKNESS = 10;
    const PADDLE_DIST_FROM_EDGE = 40;
    let paddleX = 400; // default start position for the paddle
    
    let canvas, canvasContext;

    let mouseX = 0;
    let mouseY = 0;

    function updateMousePos(e) {
      let rect = canvas.getBoundingClientRect(); // gives the position of the canvas on the page 
      let root = document.documentElement;  // 
      
      // mouse fix for majority of browsers
      mouseX = e.clientX - rect.left - root.scrollLeft; // cancel out how far the canvas is from the left side and how far the person has scrolled from side to side
      mouseY = e.clientY - rect.top - root.scrollTop; 

      paddleX = mouseX - PADDLE_WIDTH/2; 
      
    };

    // 50% chance of each brick being displayed
    function brickReset() {
      for(let i=0; i<BRICK_COLS*BRICK_ROWS; i++){
        if(Math.random() < 0.5) {
          brickGrid[i] = true;
        }else{
          brickGrid[i] = false;
        } // end of if/else (random display)

        // brickGrid[i] = true; // comment out the above and use this line to set all to true
      } // end of for loop (each brick)

      // brickGrid[5] = false; // set specific bricks to not show

    }; // end of brickReset func

    window.onload = function() {
      canvas = document.getElementById('gameCanvas');
      canvasContext = canvas.getContext('2d');

      let framesPerSecond = 30;
      setInterval(updateAll, 1000/framesPerSecond);

      canvas.addEventListener('mousemove', updateMousePos);
      brickReset();
    };

    function updateAll() {
      moveAll();
      drawAll();
    };

    function ballReset() {  // resets the ball in the centre of the canvas
      ballX = canvas.width/2;
      ballY = canvas.height/2;
    };

    function moveAll() {  // moves the ball
      ballX += ballSpeedX;
      ballY += ballSpeedY;

      // movement along x-axis
      if(ballX > canvas.width-1){ // right side
        ballSpeedX *= -1; // swap from positive to negative
      }else if(ballX < 1){ // left side
        ballSpeedX *= -1; // swap back from negative to positive
      }

      // movement along y-axis
      if(ballY > canvas.height-1){ // bottom of canvas
        ballReset(); 
        // ballSpeedY *= -1; // swap from positive to negative
      }else if(ballY < 1){ // top of canvas
        ballSpeedY *= -1; // swap back from negative to positive
      }

      // specify the 'hit' area of the paddle
      let paddleTopEdgeY = canvas.height-PADDLE_DIST_FROM_EDGE;
      let paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS;
      let paddleLeftEdgeX = paddleX;
      let paddleRightEdgeX = paddleX + PADDLE_WIDTH;

      if( ballY > paddleTopEdgeY && ballY < paddleBottomEdgeY &&   // top and bottom
          ballX > paddleLeftEdgeX && ballX < paddleRightEdgeX) {   // left and right
            ballSpeedY *= -1; // reverse direction

            let centerOfPaddleX = paddleX + PADDLE_WIDTH/2;
            let ballDistFromPaddleCenterX = ballX - centerOfPaddleX;
            ballSpeedX = ballDistFromPaddleCenterX * 0.35;  // creates a speed range along the x-axis of -17.5 (to the left) to 17.5 (to the right)
      }
    };
    
    function rowColToArrayIndex(col, row) { // function to give the index for each brick within brickGrid
      return col + BRICK_COLS * row;
    }

    function drawBricks() {
      for (let eachRow=0; eachRow<BRICK_ROWS; eachRow++ ) { // each row
        for (let eachCol=0; eachCol<BRICK_COLS; eachCol++) { // each column in that row
          
          let arrayIndex = rowColToArrayIndex(eachCol, eachRow); // gives the index for each brick
          if(brickGrid[arrayIndex]) {
            colorRect(BRICK_W*eachCol,BRICK_H*eachRow, BRICK_W-BRICK_GAP,BRICK_H-BRICK_GAP, 'blue');
          } // end of is this break here
        } // end of for each column
      } // end of for each row
    }; // end of drawBricks func

    // 
    function drawAll() { 
      colorRect(0,0, canvas.width,canvas.height, 'black'); // draw background
      colorCircle(ballX,ballY, 8, 'white'); // draw the ball
      colorRect(paddleX,canvas.height-PADDLE_DIST_FROM_EDGE, PADDLE_WIDTH,PADDLE_THICKNESS, 'white'); // draw the paddle
      drawBricks(); // draw each brick

      let mouseBrickCol = Math.floor(mouseX / BRICK_W);
      let mouseBrickRow = Math.floor(mouseY / BRICK_H);
      let brickIndexUnderMouse = rowColToArrayIndex(mouseBrickCol, mouseBrickRow);
      colorText("("+mouseBrickCol+","+mouseBrickRow+") :"+brickIndexUnderMouse, mouseX,mouseY, 'yellow'); // helps identify the array index of each brick the mouse hovers over

      if(brickIndexUnderMouse >= 0 && brickIndexUnderMouse < BRICK_COLS*BRICK_ROWS) {
        brickGrid[brickIndexUnderMouse] = false;
      }
    };

    // function to draw a rectangle
    function colorRect(topLeftX,topleftY, boxWidth,boxHeight, fillColor) {
      canvasContext.fillStyle = fillColor;
      canvasContext.fillRect(topLeftX,topleftY, boxWidth,boxHeight);
    };

    // function to draw a ball
    function colorCircle(centerX,centerY, radius, ballColor) {
      canvasContext.fillStyle = ballColor;
      canvasContext.beginPath();
      canvasContext.arc(centerX,centerY, radius, 0,Math.PI*2, true);  // position of centre, radius, draw arc (twice to make a circle), clockwise
      canvasContext.fill();
    };

    // function to display text
    function colorText(showWords, textX,textY, fillColor) {
      canvasContext.fillStyle = fillColor;
      canvasContext.fillText(showWords, textX,textY);
    };

  </script>
</body>
</html>